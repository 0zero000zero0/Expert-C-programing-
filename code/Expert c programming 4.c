#include<bits/stdc++.h>

int main()
{
//第四章：指针与数组
/*
指针与数组是两个东西，只有在一些特殊情况下（例如函数传递参数）时他们才相等
文件1：
int mango[10]
文件二
extern int *mango
该代码无法运行，因为mango定义是int的数组而在文件二的声明是指针，类型不匹配
*/
// 什么是定义，什么是声明？
// 定义：创建一个确定的对象（并非C++里的对象，而是编译和链接的东西，例如函数，变量等），并为其分配内存空间，例如int array[10];定义只能出现在一个地方，因为编译器按照定义顺序来分配内存空间，一个变量不可能有两个地址
// 声明：描述对象的类型，用于指代其他地方定义的对象，在声明后可以使用该对象，可以出现多次。例如 extern int array
// 关系：定义是一种特殊的声明，它创建了一个对象。而声明只是简单说明了有这么一个对象已经在其他地方创建，声明后可以使用。
/*
extern对象为编译器说明了对象的类型和名字，而其内存的分配则是在定义时进行的。由于extern对象并未在此处分配内存，因此不需要知道它的长度。
但是对于多为数组，需要提供除了最左边的一维之外的维度的长度，因此这样编译器才能够获得足够的信息来产生对应的目标代码。例如 extern int matrix[2][];
*/
//左值和右值
int a = 1, b = 2;
a = b;
/*
在此表达式中，a是左值，代表变量a的地址，在编译时就明确知道了，b是右值，代表变量b地址上的那个数据，这个数据是在运行时在知道的。这个赋值语句意思是把b地址上的数据放在a的地址上，至于原来a地址上的数据是什么，那个已经无关紧要了
这里的关键在于，左值代表地址，如果编译器需要一个地址（可能加上某个偏移量），那么编译器就可以直接操作，不需要取地址。
然而指针在运行前（也就是编译时）就必须知道指针的值（也就是指针的指向地址），这也就是为什么指针一定要初始化，才能继续解引用。
对于数组元素的访问而言，例如，array[i]，&array[0]=0x9980，第一步是取到偏移量i，然后在取到 0x9980+i*元素大小 地址上的内容（数据）
也说是，array[i]是转换成*(array+i)，后者中array代表的是首地址
*/

/*
这就是为什么extern数组变量不需要数组长度，因为访问是对地址偏移量的访问。
但是对于声明extern char *p，它告诉编译器这外来的变量是一个指向char的指针
例如char a='a';char *p=&a; 假设分配的地址是&a=0x5081,&pa=0x4246
如果要取得这个字符，就需要两步，首先取得地址0x4246（也就是指针p的地址）上的内容，也就是p所指向的地址（0x5081)，然后在取得地址0x5081上的内容（字符’a'）
*/

//定义为指针，但是以数组的方式访问
char *p = "abcd";//warning,最好加个const，因为右值是一个const char
char array[] = "array";
printf("%c\n", p[3]);
/*
假设&p=0x666,&"abcd"=0x999
第一步：取得地址0x666上的数值，也就是0x999
第二步：读取p[i]的i值，与0x999相加，得到0xaa2，p[i]相当于告诉编译器，从p指针所指向的地址开始，向右偏移i个步长，每个步长等于p所指地址上类型的大小
第三步：取地址0xaa2上的内容，也就是字符'd'
*/
//无论是指针还是数组都要执行第二三步，只不过指针多了第一步，但是最好还是按照本身的方式进行，以免造成莫名其妙的错误
/* 指针和数组的其他区别
1：指针用于动态数据结构而数组用于存储固定数目且类型相同的数据
2：对于字符串常量而言，指针在定义时编译器只为指针本身分配内存，除非初始化该指针，编译器就会给字符串常量也分配内存。而字符串数组无论有没有初始化所有的内存都会在定义时就分配好了。
此外，指针定义的字符串常量不能再次修改，而数组可以
*/
// *p = "a";//报错
strcpy(array, p);//没问题
puts(array);//打印abcd
//第四章只是简单地说明了数组和指针的联系与区别，后面还会再论指针与数组并且会阐述一些高级用法
//最后该书还说，一个专业C程序员要熟练使用malloc函数以及学会使用指针操纵内存
//第四章结束
system("pause");
return 0;
}