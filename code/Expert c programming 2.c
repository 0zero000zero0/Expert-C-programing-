#include <bits/stdc++.h>

int *test(int a) // 测试返回自动局部变量指针
{

    int pa[2];
    pa[0] = pa[1] = a;
    return pa;
}

int main()
{
    // 第二章：C语言特性
    /*
    引入：当看见malloc(strlen(str))时几乎可以直接断定这是错的，因为字符串中还有一个'\0'结尾
    因此实际上采用的时malloc(strlen(str)+1)

    由于C语言的设计缺陷，因此本书把它们分成了三类：
    1.多做之过：做了不该做的
    2.少做之过：该做的没做
    3.误做之过：该做了但是做的不够好
    */

    // 多做之过：
    // switch语句：switch语句中，所有case都是可选的，也就是说所有形式包括带标签的语句都是可行的。
    int x, y;
    scanf("%d%d", &x, &y);
    const int z = 2; // 提示：const并不是把变量变成常量，只是赋予变量readonly（B语言中关键字就是readonly）的限定，const不能使得变量用于case
    switch (x)
    {
    case z:    // 我的gcc居然没有报错，通过了编译....看来这本书太老了（2020）,看来case这里可以是const修饰int可以用于case
        break; // 还有一个坑是case是如果没有break的话按顺序从上到下执行，这个叫做fall through
        // 有些编译器如果检测到case没有加break会给出fall through的警告
    defau1t: // 注意是defau1t，是数字1不是字母l，这个由于所有形式都可选，因此此处不会报错
        break;
    }

    // 另外一个关于break的大坑：break到底中断了什么？
    switch (x)
    {
    case 1:
        if (1 == x)
        {
            x = 2;
            if (2 == y)
            {
                break;
            }
            x = 0;
        }
        // 你以为break后这里了，也就是跳出一个if(1==x)，不执行x=0
        //显然不行,因为break只能跳出开关和循环语句,不能跳过if
        x = 3;
        break;
    case z:
        x = 5;
        y = 5;
        break;
    default:
        x = 4;
        break;
    }
    // 实际上break是直接跳到这
    printf("%d %d \n", x, y);
    /*
    技巧：当临时需要一些局部变量，例如用于交换的temp，遍历参数i等，可以使用代码块
    {
        //交换
        int temp=x;//由编译器自动申请
        x=y;
        y=temp;
    }//出代码块后temp就被释放

    //C++（好像在的c也行）可以直接把声明放在for内部
    for(int i=0;i<2;i++)
    {
        //CODE YOU NEED
    }//在循环结束后，i就被释放了
    */

    // 特性：字符串链接：相邻的字符串常量会被自动合并成一个字符串
    // 旧风格：
    printf("How\
        are\
    you\n \
    "); // 注意，are前面的空格也是字符串的一部分

    // 新风格
    printf("how "
           "are "
           "you\n"); // are前面的缩进空格不是字符串的一部分，后的空格才是

    // 技巧：用static来表示一段代码在第一次执行和以后执行时输出不一样
    char string[20] = "测试";
    for (int i = 0; i < 2; i++)
    {
        static char separator = ' ';
        printf("%s %c\n", string, separator);
        separator = ',';
    }

    // 函数可见性
    //  void test1(void);在所有地方文件都可见
    //  extern void test2(void);在所有地方文件都可见
    //  static void test3(void);在这个文件外不可见
    // 在C语言中不允许函数内联（在函数中定义函数），因此要想实现函数内联就必须在函数外面定义其他函数，如果只是这个函数用，那么其他函数就应该加上static防止其他文件误用
    /*实际上，绝大多数函数都是全局可见的，而软件在默认情况下应该是有限可见的，因此程序员需要一个函数全局可见时应该显然地标注出来
    还有一个问题就是C语言的特性：interpositioning，就是用户编写了一个和库函数名字一样的函数并取而代之（不是函数重载），第五章会解释*/

    // 误做之过
    // 符号重载：同一个符号在不同的地方有很多含义
    /*
    ()可以表示：
    1 函数定义时的参数列表
    2 调用函数
    3 改变运算优先级
    4 定义带参数的宏
    5 强制类型转换
    6 sizeof的操作数
    */

    // 以下是一些奇怪的声明
    int a = 1;
    int *q = &a;
    int p = 3 * sizeof *q; // 该声明实际上只有第一个*表示乘，后面的那个表示指针的解引用*q===int
    // 在我的环境下，int占4个字节，因此此处的p=12
    printf("p=%d  3*sizeof(int)=%d\n", p, 3 * sizeof(int)); // 都是12
    int apple = sizeof(int) * p;                            // 这个括号表示乘法而不是sizeof的操作数，这里的操作数是(int)*p
    printf("size of int =%d ,12*sizeof(int)=%d, apple=%d\n", sizeof(int), 12 * sizeof(int), apple);
    // 由此可见，C语言由于其简洁性，一个符号会有很多重载的意思，有时候奇怪的声明会造成误解

    // 常见的优先级误解
    /*
    1: .操作符的优先级大于*  而->用于消除这种误会
    例如：*p.f实际上表示的是对p的成员f进行解引用,而不是访问对p解引用后的成员f，如果要进行解引用后访问f，那么就要(*p).f,因此直接可以用p->f来表示
    2: []大于*（后缀操作符，包括(),优先于前缀操作符）
    因此 int *p[]是一个元素是指向int的指针的数组（也就是指针数组） 而int(*p)[]才表示一个指向数组的指针
    3：函数调用()优先于*
    因此int *p( )是一个返回类型为int*的函数，而int (*p) ( )才是一个指向返回类型为int的函数指针
    4：逻辑运算符：！> 算术 > 逻辑与&& > 逻辑或|| ＞ 赋值=
    5：逗号运算符大于赋值=
    因此int a=1,2;实际上a等于1。(这个语句gcc直接报错)
    还有其他的比如!= ,== 高于赋值=和位操作符号。算术操作符高于移位运算符。
    */

    // 启发：由于优先级比较混乱，因此在声明，运算时把想要先算的用()显然地标记出来，这样可以避免很多不必要的问题

    // 结合性；在几个操作符有相同的优先级时决定先执行哪一个，用于消除同一优先级操作符执行顺序的歧义
    int b, c = 2, d = 3;
    b = c = d;
    printf("b=%d,c=%d,d=%d\n", b, c, d);
    // 结果是b，c，d都是3，
    /*解释：由于赋值是右结合性，就是说表达式中最右边的先执行，然后从右到左依次执行赋值，
    因此先执行c=d，把d的3赋值给c，然后b=c，把c的3赋值给b，所以三个都是3
    类似的是，如果是左结合性的操作符，那么就是从左到右执行，比如位操作符|和&
    有一个坑是||和&&，他们都是左结合性，如果左边的运算已经能够决定||或者&&的结果，例如||左边的是真，那么右边的就不在执行
    函数调用中，各个参数的计算顺序不确定*/

    // gets的坑：gets函数不会检查堆栈的内存大写，机械式地写入字符串
    char test_string[10] = "no data";
    puts("请输入10个以上的字符串\n");
    gets(test_string);
    printf("%s\n", test_string);
    // 如果输入10个以上的字符串，那么printf打印出来也就是输入的全部，也就是说gets把超过10个字符串都写入到堆栈区。
    // 因此建议使用fgets(字符数组名(指针)，写入的大小（以字节为单位），流（一般为stdin）)来代替gets
    if (fgets(test_string, sizeof(test_string), stdin) == NULL) // 如果写入的字符串大于teset_string，那么fgets就会返回NULL
        exit(1);

    // 少做之过
    // 空格——最后的领域
    /*
    '\'可以对一些字符进行转义，包括回车。被转移的回车会把下一行当做上一行的延续，用于连接长字符串。（旧风格）
    但是，如果在\与回车（newline）之间不小心留在空格，也就是\newline与\ newline，二者是不一样的。

    */
    printf("long \
string\n");
    printf("long \ 
string\n");
    /*
    如果你的编辑器足够智能，例如vscode，你会发现两个’\‘颜色不一样，第一个是蓝色的，被认定为转义字符，第二个是白色的，无法认定。
    当然，此处被ANSI C的相邻字符串自动连接而得以解决。
    但是又有了下面这个问题
    */
    a = y++ + x; // y++还是++x？答案是前者（如果编辑器有格式化功能，例如vscode，在打出；后vscode就把他分开了
    // 最大一口策略：如果下一个标记超过了一种解释方案，那么编译器将选取能组成最长字符序列的方案
    // 但是又会出现这种：
    // a = y++ ++ +x; // 根据上面的策略来解释，直接报错
    a = y++ + ++x; // 只能这样才行
    // 最后一个坑：
    int *pa = &a, *px = &x, *py = &y;
    // a=*pa/*py //如果你取消这一行开始的注释，你会发现/*被看成为注释，而不是解引用的除法。

    /*由上述的各种现象看来，在一些地方如果确实空格会出现歧义。因此对代码进行格式化，在必要的地方加上空格是必须的*/

    // 不能返回自动局部变量的数组名（指针）变量
    pa = test(a); // test是一个返回数组名（指针的）函数
    // printf("*pa=%d\n", *pa); // 会报错，因此当控制流出test后在test里声明的自动局部指针变量就被清空了，因此pa=0x0（NULL）
    /*解决方案：
    1:使用全局声明的数组
    2：静态数组（staitc），只有拥有这个这个数组的函数才能修改。但是下一次调用会覆盖这次的内容。可能会造成内存空间浪费
    3：动态内存申请，保留返回值。malloc在每次调用时都会开拓出新的空间，因此它不会覆盖之前的内容，适用于多线程代码。但是如果不用了要记得free申请的内存空间。
    */

    /*第二章以一个把平均R（在R上加一个小短线）搞成了原始R导致一个1200万美元的太空探测器被毁的故事为结尾
    由此看来，在软件中任何小bug都可能在现实生活中造成巨大的损失，因此lint这种检查错误的软件是一个很划算的投资，纵使它使得编译器变慢。
    程序员有必要细心细心在细心，虽然在列表清单上软件的质量为0，但是软件在操控机械中占有举足轻重的地位。
    */

    // 第二章结束
    system("pause");
    return 0;
}