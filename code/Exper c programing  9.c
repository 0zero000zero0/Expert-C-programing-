#include <bits/stdc++.h>
    char a[10] = "abcdefghl";
void f1(char a[])
{
    printf("&a=%p,&(a[0])=%p,&(a[1])=%p\n", &a, &(a[0]), &(a[1]));
}
void f2(char *a)
{
    printf("&a=%p,&(a[0])=%p,&(a[1])=%p,++a=%p\n", &a, &(a[0]), &(a[1]),++a);
}
int main()
{
    // 第九章：再论数组
    char str[10] = "It's ok";
    printf("%d\n%d\n", sizeof(str), sizeof(&str[0]));
    printf("%p,%p\n", str, &str[0]); // 二者相同，说明数组名确实代表函数首地址
    /*
    指针和数组相同的情况
    1 作为函数参数时，数组形式和指针形式是一样的
    2 在表达式中，p[i]与*(p+i)是一样的
    */

    /*
    一些规则：
    1 在表达式中的数组名就是指向第一个元素的指针常量
    2 C语言把数组下标作为指针的偏移量
    //1、2一起理解，对数组下标引用会被转化为数组名+偏移量的指针的解引用
    */
    // 根据1、2，可以得到一下三种对于元素a[i]的引用方式
    int array[10] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10}, *p, i = 2;
    {
        // 第一种引用
        p = array;
        p[i];
        printf("%d\n", p[i]);
    }
    {
        // 第二种引用
        p = array;
        *(p + i);
        printf("%d\n", *(p + i));
    }
    {
        // 第三种引用
        p = array + i; // 编译器会自动转化步长，这就是为什么指针一定要有指向类型，只有这样编译器才能在偏移量中转化出步长
        *p;
        printf("%d\n", *p);
    }
    /*为什么C语言把数组的形参当做指针：
    如果数组长度较长，在复制出一份数组就需要较多的空间和时间，这样会降低效率，但是如果把数字名当做指针，通过指针偏移量来访问数组元素，
    那么就可以大幅度提高效率,而且函数不需要知道整个数组的副本,而是某一时刻的特定数组的某个元素.
    此外这样子还能简化编译器
    因此函数的返回值也不能说数组,只能是数组指针或者是函数指针(函数也一样的)
    有一个坑是如果传入的是数组的第2个元素，也就是a【1】，但是在函数里依然把它当做第一个元素，此时函数里的a[1]实际上对应的是a[2]
    */

    f1(a);
    f2(a);
    printf("&a=%p,&(a[0])=%p,&(a[1])=%p\n", &a, &(a[0]), &(a[1]));
//可以发现，除了&a其他的两个在函数f1，f2和mian里都是一样的，因为传入指针后函数在自己的空间内拷贝出一份指向a[0]的指针

//多维数组
    char  apricot[2][3][5];
        for (int i= 0; i < 2;i++)
        for (int j = 0; j < 3;j++)
            for (int k = 0; k < 5;k++)
                apricot[i][j][k] = 1;
    //不同层级代表的类型，规则1
    char (*px)[3][5] = apricot;
    char (*r)[5] = apricot[0];
    char  *t = apricot[0][0];
    char  u = apricot[0][0][0];
    printf("sizeof:\n *px=%d,*r=%d,*t=%d,u=%d\n", sizeof(*px), sizeof(*r), sizeof(*t), sizeof(u));
    //sizeof :*p=15,*r=5,*t=u=1由此可见其类型大小，在++和--时的步长也就是这里的sizeof
    printf("px=%p,px++=%p\n", px, px++);//px与px++差15
//C语言中遵循的是列主列，也就是在内存中，最右边的下标最先开始变化，当最右边的下标满了后，次最右边的下标才开始变化（同时最右边的下标归零）
//第九章结束
    system("pause");
    return 0;
}
